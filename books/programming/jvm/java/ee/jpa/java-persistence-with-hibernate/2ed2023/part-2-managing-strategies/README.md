# Part 2. Mapping strategies
## Chapter 4. Mapping persistent classes
### 4.1. Understanding *entities* and *value types*
#### 4.1.1. Fine-grained domain models
design tip: when designing an `EmailAddress` *value* class, it may provide a `prepareEmail()` method (but not `sendEmail()` because it is a bad idea to make this `EmailAddress` class have dependency on the email sub-system)
#### 4.1.2. Defining application concepts
design tip: 
 * since you want to have CRUD operation on `User` => `User` is an entity
 * take `Address` as an example, if there exists `Address` being shared among multiple `User` then the `Address` is an `Entity` - think about it, when removing a `User` you cannot remove the `Address` if it is shared by other users

> An instance of *value type* has no persistence identifier property, it belongs to an entity instance. Its lifespan is bound to the owning entity instance. => A value type doesn't support shared references. 

#### 4.1.3. Distinguishing entities and value types
design tip: 
 * use stereotype in UML to differentiate between *entity* and *value type*
 * relationship between an entity and its *value types* is *composition* especially from the lifecycle aspect
 * prefer always *value type* to *entity* (this kinda corresponds to the OO design principle - favor composition over inheritance)
 * strive for simplicity: persistent collections, e.g., frequently add complexity without any benifit. For instance, instead of mapping `Item#bids` and `User#bids`, query all `bids` for `Item`/`User`
3 key things in JPA design:
 * shared references
 * life-cycle dependencies
 * identity

### 4.2. Mapping entities with identity
*database identity* : Objects stored in database are identical if they share the same table and primary key value
#### 4.2.2. A first entity class and mapping
`Long getId()` is optional but useful

> Hibernate will use the field to access the identifier property value when loading and storing items, not *getter* or *setter* method.

design tip: `setId()` method can be added, but it is not necessary and in practice it might add complexity to the whole system

#### 4.2.3. Selecting a primary key
*candidate key* : a column or set of columns that could be used to identify a single row in a table.

Requirement on candidate key:
 * value of any candidate key column cannot not be null
 * uniqueness
 * *immutable* (this indicates why no need a `setId()` method on an entity usually)

*natural key* : a key with business meaning - an attribute or combination of attributes that is unique by virtual of its business semantics
Example of *natural keys* : social security number, Australian Tax File Number etc.

practical experience: *natural key* as *primary key* usually end up with problems!
=> 
recommendation: *surrogate keys* as *primary key* 
surrogate key: no business meaning: a unique value generated by the database or application

#### 4.2.4. Configuring key generators
#### 4.2.5. Identifier generator strategies
design tip: prefer pre-insert generation strategies that produce identifier values independently before `insert` - database `sequence`

learning:
> Autoincremented columns, column default values, or trigger-generated keys are only available **after the `INSERT`**
### 4.3. Entity-mapping options
#### 4.3.1 Controlling names
Learning: SQL is case-insensitive

Override table name - `@Table(name="new_name")`

#### 4.3.3. Make an entity *immutable*
design tip: 
* *immutable* (not JPA stanadard but only Hibernate feature) entity avoids *dirty checking* => performance improvement
* JSF doesn't access fields directly to populate an instance
#### 4.3.4. Mapping an entity a sub-select

## Chapter 5. Mapping Value Types

Category of *value types* (class) :
 * basic: `String`, `Date`
 * developer-defined/custom
### 5.1. Mapping basic properties
design tip: Always map Java classes instead of storing a heap of bytes in the database

*configuration by exception*
#### 5.1.1. Overriding basic property defaults



design tip: favor `@Column` over `@Basic`
#### 5.1.2. Customizing property access
design type: 
 * if `@Id` is placed on a field => all other JPA annotations are also on fields
 * IMPORTANT: annotations are never on the setter methods!

default `AccessType` is `FIELD` in `@Access` (how instance is accessed). `AccessType.PROPERTY` means to parse annotations from *getter* methods

#### 5.1.3. Using derived properties (Hibernate features)
#### 5.1.4. Transforming column values (Hibernate features)
#### 5.1.5. Generated and default property values (Hibernate features)
#### 5.1.6. *Temporal* properties
`@Temporal`
design tip: timestamp property is saved once by never updated
#### 5.1.7. Mapping annotations
design tip: `EnumType.STRING` is a better choice
### 5.2. Mapping embeddable components
#### 5.2.1. Database schema
*value type* can't be shared => *value type* has no identity. 

an *embedded component* has a dependent lifecycle (dependent on its owning entity)

#### 5.2.2. Making classes embeddable 
`@Embeddable` class has no identifier property

### 5.3. Mapping Java and SQL types with converters
*Java-to-SQL type conversion*
#### 5.3.1. built-in types
##### Primitives and Numeric Types

#### 5.3.2. Creating Custom JPA Converters
*value-typed class* 
 * *immutable* 
 * should `implements Serializable` when Hibernate stores entity instance data in the shared second-level cache
##### CONVERTING BASIC PROPERTY VALUES
A *converter* must 
 * `implements AttributeConverter`
 * annotate with `@Converter`: `autoPlay` comes into play typically when an type class is used as an attribute in many different entities inside the same *persitance unit* and, we might want to convert it differently as to different entities

NOTE! use of `@Convert` onto the field of entity is optional. It comes into use typically when there are multiple `AttributeConverter` implementions on the same field class type, then it is necessary to define the `converter` element of the `@Convert` annotation. The other element `disabled` is trivial to understand

##### Character Types

## Chapter 6. Mapping Inheritance
### 6.8 *Polymorphic associations*
#### 6.8.1 Polymorphic *many-to-one* associations

**SELF COMMENT**
In practice, use of `@ManyToOne(fetch = FetchType.LAZY)` in combination with *JsonB* causes error because
> Hibernate will proxy the association target

```
05:42:49,506 SEVERE [org.eclipse.yasson.internal.SerializationContextImpl] (default task-1) Generating incomplete JSON
05:42:49,511 ERROR [org.jboss.resteasy.core.providerfactory.DefaultExceptionMapper] (default task-1) RESTEASY002375: Error processing request GET /dictionary-rest-api/rest/glossary/en/take - rx.dictionary.rest.DictionaryResource.getDictionaryEntry: jakarta.ws.rs.ProcessingException: RESTEASY008205: JSON Binding serialization error jakarta.json.bind.JsonbException: Unable to serialize property 'lexicalItem' from io.github.rxue.dictionary.jpa.entity.Explanation
	at org.jboss.resteasy.resteasy-json-binding-provider@6.2.1.Final//org.jboss.resteasy.plugins.providers.jsonb.JsonBindingProvider.asyncWriteTo(JsonBindingProvider.java:234)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ServerWriterInterceptorContext.writeTo(ServerWriterInterceptorContext.java:87)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.AbstractWriterInterceptorContext.asyncProceed(AbstractWriterInterceptorContext.java:203)
	at org.jboss.resteasy.resteasy-crypto@6.2.1.Final//org.jboss.resteasy.security.doseta.DigitalSigningInterceptor.asyncAroundWriteTo(DigitalSigningInterceptor.java:169)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.AbstractWriterInterceptorContext.asyncProceed(AbstractWriterInterceptorContext.java:211)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.AbstractWriterInterceptorContext.getStarted(AbstractWriterInterceptorContext.java:166)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ServerWriterInterceptorContext.lambda$getStarted$0(ServerWriterInterceptorContext.java:73)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ServerWriterInterceptorContext.aroundWriteTo(ServerWriterInterceptorContext.java:93)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ServerWriterInterceptorContext.getStarted(ServerWriterInterceptorContext.java:73)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.ServerResponseWriter.lambda$writeNomapResponse$3(ServerResponseWriter.java:172)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ContainerResponseContextImpl.filter(ContainerResponseContextImpl.java:410)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.ServerResponseWriter.executeFilters(ServerResponseWriter.java:261)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.ServerResponseWriter.writeNomapResponse(ServerResponseWriter.java:101)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.ServerResponseWriter.writeNomapResponse(ServerResponseWriter.java:74)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.writeResponse(SynchronousDispatcher.java:594)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:524)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.lambda$invoke$4(SynchronousDispatcher.java:261)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.lambda$preprocess$0(SynchronousDispatcher.java:161)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.PreMatchContainerRequestContext.filter(PreMatchContainerRequestContext.java:364)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.preprocess(SynchronousDispatcher.java:164)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:247)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(ServletContainerDispatcher.java:249)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:60)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:55)
	at jakarta.servlet.api@6.0.0//jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129)
	at io.smallrye.opentracing-contrib//io.smallrye.opentracing.contrib.jaxrs2.server.SpanFinishingFilter.doFilter(SpanFinishingFilter.java:69)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:67)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:68)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)
	at org.wildfly.security.elytron-web.undertow-server@3.0.0.Final//org.wildfly.elytron.web.undertow.server.ElytronRunAsHandler.lambda$handleRequest$1(ElytronRunAsHandler.java:68)
	at org.wildfly.security.elytron-base@2.0.0.Final//org.wildfly.security.auth.server.FlexibleIdentityAssociation.runAsFunctionEx(FlexibleIdentityAssociation.java:103)
	at org.wildfly.security.elytron-base@2.0.0.Final//org.wildfly.security.auth.server.Scoped.runAsFunctionEx(Scoped.java:161)
	at org.wildfly.security.elytron-base@2.0.0.Final//org.wildfly.security.auth.server.Scoped.runAs(Scoped.java:73)
	at org.wildfly.security.elytron-web.undertow-server@3.0.0.Final//org.wildfly.elytron.web.undertow.server.ElytronRunAsHandler.handleRequest(ElytronRunAsHandler.java:67)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.RedirectDirHandler.handleRequest(RedirectDirHandler.java:68)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:117)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57)
	at io.undertow.core@2.3.0.Final//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at io.undertow.core@2.3.0.Final//io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64)
	at io.undertow.core@2.3.0.Final//io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43)
	at org.wildfly.security.elytron-web.undertow-server-servlet@3.0.0.Final//org.wildfly.elytron.web.undertow.server.servlet.CleanUpHandler.handleRequest(CleanUpHandler.java:38)
	at io.undertow.core@2.3.0.Final//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
	at io.undertow.core@2.3.0.Final//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.GlobalRequestControllerHandler.handleRequest(GlobalRequestControllerHandler.java:68)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.SendErrorPageHandler.handleRequest(SendErrorPageHandler.java:52)
	at io.undertow.core@2.3.0.Final//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:275)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:134)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:131)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:255)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:100)
	at io.undertow.core@2.3.0.Final//io.undertow.server.Connectors.executeRootHandler(Connectors.java:391)
	at io.undertow.core@2.3.0.Final//io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:859)
	at org.jboss.threads@2.4.0.Final//org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)
	at org.jboss.threads@2.4.0.Final//org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1990)
	at org.jboss.threads@2.4.0.Final//org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)
	at org.jboss.threads@2.4.0.Final//org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1348)
	at org.jboss.xnio@3.8.8.Final//org.xnio.XnioWorker$WorkerThreadFactory$1$1.run(XnioWorker.java:1282)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: jakarta.json.bind.JsonbException: Unable to serialize property 'lexicalItem' from io.github.rxue.dictionary.jpa.entity.Explanation
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.lambda$serialize$0(ObjectSerializer.java:43)
	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:721)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.serialize(ObjectSerializer.java:38)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.RecursionChecker.serialize(RecursionChecker.java:38)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.KeyWriter.serialize(KeyWriter.java:41)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullVisibilitySwitcher.serialize(NullVisibilitySwitcher.java:40)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.findSerializer(ObjectTypeSerializer.java:68)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serializeValue(ObjectTypeSerializer.java:50)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer$ValueSerializer.serialize(TypeSerializer.java:51)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer.serialize(TypeSerializer.java:37)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serialize(ObjectTypeSerializer.java:31)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.CollectionSerializer.lambda$serialize$0(CollectionSerializer.java:37)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.CollectionSerializer.serialize(CollectionSerializer.java:37)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.KeyWriter.serialize(KeyWriter.java:41)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullVisibilitySwitcher.serialize(NullVisibilitySwitcher.java:40)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.SerializationContextImpl.serializeObject(SerializationContextImpl.java:197)
	at org.eclipse.yasson//org.eclipse.yasson.internal.SerializationContextImpl.marshall(SerializationContextImpl.java:133)
	at org.eclipse.yasson//org.eclipse.yasson.internal.SerializationContextImpl.marshall(SerializationContextImpl.java:159)
	at org.eclipse.yasson//org.eclipse.yasson.internal.JsonBinding.toJson(JsonBinding.java:121)
	at org.jboss.resteasy.resteasy-json-binding-provider@6.2.1.Final//org.jboss.resteasy.plugins.providers.jsonb.ManagedJsonb.toJson(ManagedJsonb.java:78)
	at org.jboss.resteasy.resteasy-json-binding-provider@6.2.1.Final//org.jboss.resteasy.plugins.providers.jsonb.JsonBindingProvider.asyncWriteTo(JsonBindingProvider.java:223)
	... 72 more
Caused by: jakarta.json.bind.JsonbException: Unable to serialize property 'hibernateLazyInitializer' from io.github.rxue.dictionary.jpa.entity.LexicalItem$HibernateProxy$0lYwZSxP
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.lambda$serialize$0(ObjectSerializer.java:43)
	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:721)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.serialize(ObjectSerializer.java:38)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.RecursionChecker.serialize(RecursionChecker.java:38)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.KeyWriter.serialize(KeyWriter.java:41)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullVisibilitySwitcher.serialize(NullVisibilitySwitcher.java:40)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.findSerializer(ObjectTypeSerializer.java:68)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serializeValue(ObjectTypeSerializer.java:50)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer$ValueSerializer.serialize(TypeSerializer.java:51)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer.serialize(TypeSerializer.java:37)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serialize(ObjectTypeSerializer.java:31)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ValueGetterSerializer.serialize(ValueGetterSerializer.java:43)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.lambda$serialize$0(ObjectSerializer.java:41)
	... 96 more
Caused by: jakarta.json.bind.JsonbException: Error accessing getter 'getEnclosingConstructor' declared in 'class java.lang.Class'
	at org.eclipse.yasson//org.eclipse.yasson.internal.model.PropertyModel.createReadHandle(PropertyModel.java:500)
	at org.eclipse.yasson//org.eclipse.yasson.internal.model.PropertyModel.<init>(PropertyModel.java:157)
	at org.eclipse.yasson//org.eclipse.yasson.internal.ClassParser.lambda$parseProperties$0(ClassParser.java:70)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$ValueSpliterator.forEachRemaining(HashMap.java:1779)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)
	at org.eclipse.yasson//org.eclipse.yasson.internal.ClassParser.parseProperties(ClassParser.java:71)
	at org.eclipse.yasson//org.eclipse.yasson.internal.MappingContext.lambda$createParseClassModelFunction$1(MappingContext.java:104)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1740)
	at org.eclipse.yasson//org.eclipse.yasson.internal.MappingContext.getOrCreateClassModel(MappingContext.java:77)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.serializerChainInternal(SerializationModelCreator.java:187)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.serializerChain(SerializationModelCreator.java:137)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.memberSerializer(SerializationModelCreator.java:378)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.createObjectSerializer(SerializationModelCreator.java:213)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.serializerChainInternal(SerializationModelCreator.java:199)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.serializerChainRuntime(SerializationModelCreator.java:123)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.lambda$findSerializer$0(ObjectTypeSerializer.java:67)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.findSerializer(ObjectTypeSerializer.java:65)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serializeValue(ObjectTypeSerializer.java:50)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer$ValueSerializer.serialize(TypeSerializer.java:51)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer.serialize(TypeSerializer.java:37)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serialize(ObjectTypeSerializer.java:31)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ValueGetterSerializer.serialize(ValueGetterSerializer.java:43)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.lambda$serialize$0(ObjectSerializer.java:41)
	... 110 more
Caused by: java.lang.IllegalAccessException: Attempt to lookup caller-sensitive method using restricted lookup object
	at java.base/java.lang.invoke.MethodHandles$Lookup.findBoundCallerLookup(MethodHandles.java:3714)
	at java.base/java.lang.invoke.MethodHandles$Lookup.unreflect(MethodHandles.java:3350)
	at org.eclipse.yasson//org.eclipse.yasson.internal.model.PropertyModel.createReadHandle(PropertyModel.java:497)
	... 139 more
```

In order to avoid the error mentioned above, You can avoid these issues by forcing eager fetch with `fetch` keyword in the JPQL

reference: http://jpwh.org/examples/jpwh2/jpwh-2e-examples-20151103/examples/src/test/java/org/jpwh/test/inheritance/PolymorphicManyToOne.java

#### 6.8.2 Polymorphic collections
example of `abstract class` entity with `@Entity` annotation: http://jpwh.org/examples/jpwh2/jpwh-2e-examples-20151103/model/src/main/java/org/jpwh/model/inheritance/associations/onetomany/BillingDetails.java

label: `1Z0-900`

## Chapter 7. Managing collections and entity associations
Heart of ORM : manage associations between classes and relationships between tables
**Major new features in JPA 2**
### 7.1. Sets, bags, lists and maps of value types
#### Selecting a collection interface
`java.util.Collection` - *bag* semantics
#### 7.1.5. Mapping an identifier *bag*
*Bag* : an *unordered collection* that allows duplicate elements

### 7.2. Collections of components
#### 7.2.2. Set of components

### 7.3. Mapping entity associations
> The term *parent/child* implies some kind of *life cycle dependencies*

*Association* between entity classes don't have a dependent life cycle: An instance can be saved, updated, and removed without affecting any other

#### 7.3.1. The simplest possible association
> when you see a *foreign key* column and two entity classes involved, you should probably map it with `@ManyToOne` and nothing else

**My own practice of unidirectional `@OneToMany`:** https://github.com/rxue/dictionary/issues/129

#### 7.3.2. Making it bidirectional
demo code reference: http://jpwh.org/examples/jpwh2/jpwh-2e-examples-20151103/model/src/main/java/org/jpwh/model/associations/onetomany/bidirectional/Bid.java

Mapping collection in `@OneToMany` association has the following 2 features:
* *lazy load* on the collection, in the example the `Bid` collection is loaded only when `item.getBids()` is called => primary benifit of `@OneToMany`: *navigational access* to data - access data data by calling only methods of Java *domain model*
* *cascade* state change: typically on *delete* and *save* operation (configurable)


primary benifit of `@OneToMany`: *navigational access* to data - access data data by calling only methods of Java *domain model*

But in practice, ask yourself do you always need all of the *many* side of `@OneToMany`, i.e. the `Bid` collections in the example? **If you usually need only a *subset* of the collection or need sorting, the extra Java code brings about significant complexity! This is the mentioned *maintenance baggage*** As to such case, the author mentioned:

> In our experience, this is frequent source of problems and bugs, especially for ORM beginners

`mappedBy` element is compulsory on the *one* side of the `@OneToMany` association

#### 7.3.3. Cascading state
demo code: http://jpwh.org/examples/jpwh2/jpwh-2e-examples-20151103/examples/src/test/java/org/jpwh/test/associations/OneToManyBidirectional.java

## Chapter 8. Advanced entity association mappings
### 8.2 one-to-many associations

## Chapter 9. Complex and legacy schemas
### 9.1. Improving the database schema
#### 9.1.2. SQL Constraints
> Systems that ensure data integrity only in application code are prone to data corruption and often degrade the quality of the database over time. If the data store doesnâ€™t enforce rules, a trivial undetected application bug can cause unrecoverable problems such as incorrect or lost data.
